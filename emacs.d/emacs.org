#+TITLE: Nox's Emacs Configuration
#+AUTHOR: Noah Frederick

* Usage

** Obtaining the Source

   You can find the latest version of the configuration in [[https://github.com/noahfrederick/dots][the GitHub
   repository]]. The meat of it (and the source of this document) is the
   ~emacs.org~ file.

** Installation

   This configuration is intended to be installable from scratch. It
   uses [[https://github.com/cask/cask][Cask]] to specify the package dependencies. [[https://github.com/rdallasgray/pallet][Pallet]] allows us to
   use Cask in conjunction with ~package.el~.

  - Install GNU Emacs 24 or higher
  - Install Cask from https://github.com/cask/cask
  - Run ~cask install~ in ~$HOME/.emacs.d~

** Commentary

   Any variables, functions, or macros defined in this configuration
   are "namespaced" with a prefix of =nox/=. This is only a convention
   for easily distinguishing between built-in functions and those
   defined in this configuration or another package, and has no other
   special significance.

** Configuring Packages

   We use [[https://github.com/jwiegley/use-package][=use-package=]] to autoload packages throughout:

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'use-package)
   #+END_SRC

** Benchmarking

   It's useful to measure how long it takes Emacs to start up, so
   let's show the total time in a message:

   #+NAME: init-after
   #+BEGIN_SRC emacs-lisp :tangle no :tangle no
     (defun nox/show-load-time ()
       "Show load time in minibuffer"
       (message "Load time: %s seconds."
                (emacs-uptime "%s")))

     (add-hook 'emacs-startup-hook 'nox/show-load-time 'append)
   #+END_SRC

* Emacs Initialization

** Paths

   Keep any Elisp files not installed from a package repository in the
   ~vendor/~ directory:

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar nox/vendor-directory (concat user-emacs-directory "vendor/"))
     (add-to-list 'load-path nox/vendor-directory)
   #+END_SRC

   Keep theme files in the ~themes/~ directory:

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq custom-theme-directory (concat user-emacs-directory "themes/"))
   #+END_SRC

   Keep temporary files in a separate directory:

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar nox/ephemeral-directory "~/.emacs.ephemeral/")
     (unless (file-exists-p nox/ephemeral-directory)
       (mkdir nox/ephemeral-directory))
   #+END_SRC

** Platform-specific

   There are a few settings that are only relevant to OS X (Darwin):

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (cond ((eq system-type 'darwin)
            (setq delete-by-moving-to-trash t)
            (setq trash-directory "~/.Trash/")
            ;; Use gls for dired: brew install coreutils
            (setq insert-directory-program "gls")
            (exec-path-from-shell-initialize)))
   #+END_SRC

** Start Server

   #+NAME: init-after
   #+BEGIN_SRC emacs-lisp :tangle no
     ;(use-package server
       ;:init
       ;(unless (server-running-p)
         ;(server-start)))
   #+END_SRC
** Temporary Files

   #+NAME: init-after
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq backup-directory-alist
           `((".*" . ,temporary-file-directory)))
     (setq auto-save-file-name-transforms
           `((".*" ,temporary-file-directory t)))
     (setq-default make-backup-files nil)
   #+END_SRC

** Private

   Since this configuration is kept in version control in public view,
   we keep sensitive information such as passwords in separate
   file. Anything with the special prefix =nox/private/= originates from
   this file.

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar nox/private-file (expand-file-name "private.el" user-emacs-directory))
     (load nox/private-file 'noerror)
   #+END_SRC

** Custom

   Set alternative location for ~custom-set-variables~ and ~custom-set-faces~:

   #+NAME: init-after
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (load custom-file 'noerror)
   #+END_SRC

* Appearance

** UI

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
     (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

     (load-theme 'enox t)
     ;(load-theme 'solarized-light t)
     (set-frame-font "Panic Sans-14" t t)

     (global-hl-line-mode)

     ;; http://stackoverflow.com/questions/335487/programmatically-setting-emacs-frame-size
     ;;
     ;; TODO always maximize height:
     ;; The developer build of Emacs Trunk has a function called
     ;; toggle-frame-maximized, which is included within
     ;; .../lisp/frame.el. That function can be added to the
     ;; after-init-hook or emacs-startup-hook, or simply included in the
     ;; .emacs file that gets loaded on startup. On OSX, it increases
     ;; both width and height in one-fell-swoop.
     ;;
     ;; Source: http://stackoverflow.com/a/18711628
     (add-to-list 'default-frame-alist '(left . 0))
     (add-to-list 'default-frame-alist '(top . 0))
     (add-to-list 'default-frame-alist '(height . 67))
     (add-to-list 'default-frame-alist '(width . 234))

     ;; Set up terminal frames appropriately
     (defun nox/after-make-frame (frame)
       (if (display-graphic-p frame)
           (set-frame-font "Panic Sans-14" t t)
         ;; else
         (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
         (set-face-background 'default "dummy-color" frame)))

     (add-hook 'after-make-frame-functions 'nox/after-make-frame)

     (setq ring-bell-function 'ignore)
     (setq inhibit-startup-screen t)

     ;; Set message for *scratch* buffer
     (setq initial-scratch-message ";; Hello, Nox.\n")

     ;; Use ANSI color in shell
     (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

     ;; Never require full word answers
     (defalias 'yes-or-no-p 'y-or-n-p)

     (setq linum-format "%5d ")
     (add-hook 'prog-mode-hook 'linum-mode)
   #+END_SRC

** Mode-line

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package smart-mode-line
       :init
       (progn
         (if after-init-time (sml/setup)
           (add-hook 'after-init-hook 'sml/setup))

         (setq sml/override-theme nil)

         (add-to-list 'sml/replacer-regexp-list '("^~/Sites/\\([-_A-Za-z0-9.]+\\)/www/" ":\\1:"))
         (add-to-list 'sml/replacer-regexp-list '("^~/Sites/\\([-_A-Za-z0-9.]+\\)/\\([-_A-Za-z0-9]+\\)/" ":\\2.\\1:"))
         (add-to-list 'sml/replacer-regexp-list '("^~/gh/\\(.*\\)/" ":Git:\\1:"))
         (add-to-list 'sml/replacer-regexp-list '("^~/org/" ":Org:"))

         (add-to-list 'sml/hidden-modes " Projectile")
         (add-to-list 'sml/hidden-modes " Undo-Tree")
         (add-to-list 'sml/hidden-modes " Guide")
         (add-to-list 'sml/hidden-modes " yas")))
   #+END_SRC

** Delimiters

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package parenface)
     (use-package rainbow-delimiters
       :commands rainbow-delimiters-mode
       :init
       (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))

     (show-paren-mode t)
   #+END_SRC

** Color Names and Codes

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package rainbow-mode
       :commands rainbow-turn-on
       :init
       (add-hook 'prog-mode-hook 'rainbow-turn-on))
   #+END_SRC

* Evil

** Setup

   #+NAME: evil
   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'evil-leader)
     (require 'evil)
     (require 'evil-numbers)

     (evil-mode nil) ; See https://github.com/cofi/evil-leader/issues/10
     (global-evil-leader-mode 1)
     (evil-mode 1)

     (setq evil-want-C-u-scroll t
           evil-want-C-w-in-emacs-state t)

     (setq evil-default-cursor '("white" box)
           evil-emacs-state-cursor '("pink" box)
           evil-insert-state-cursor '("white" bar)
           evil-visual-state-cursor '("white" hbar)
           evil-replace-state-cursor '("orange" hbar))
   #+END_SRC

** TODO Miscellaneous Bindings

   #+NAME: evil
   #+BEGIN_SRC emacs-lisp :tangle no
     (global-set-key (kbd "RET") 'newline-and-indent)

     (evil-leader/set-key
       "b" 'ido-switch-buffer
       "B" 'ibuffer
       "f" 'fiplr-find-file
       "d" 'fiplr-find-directory
       "D" 'dired
       "T" 'nox/write-timestamped-current-file-copy
       "s" 'ansi-term
       "h" 'dash-at-point
       "P" 'package-list-packages
       "=" 'nox/indent-buffer
       ;; TODO: move out of leader
       "con" 'linum-mode
       "cow" 'toggle-truncate-lines
       ;; Git
       "g s" 'magit-status
       "g l" 'magit-log
       "g d" 'magit-diff)

     (define-key evil-motion-state-map "j" 'evil-next-visual-line)
     (define-key evil-motion-state-map "k" 'evil-previous-visual-line)
     (define-key evil-normal-state-map "Y" (kbd "y$"))

     (define-key evil-normal-state-map "+" 'evil-numbers/inc-at-pt)
     (define-key evil-normal-state-map "_" 'evil-numbers/dec-at-pt)

     ;; Escape minibuffer
     (defun nox/minibuffer-keyboard-quit ()
       "Abort recursive edit.

     In Delete Selection mode, if the mark is active, just deactivate it;
     then it takes a second \\[keyboard-quit] to abort the minibuffer."
       (interactive)
       (if (and delete-selection-mode transient-mark-mode mark-active)
           (setq deactivate-mark t)
         (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
         (abort-recursive-edit)))

     (define-key minibuffer-local-map [escape] 'nox/minibuffer-keyboard-quit)
     (define-key minibuffer-local-ns-map [escape] 'nox/minibuffer-keyboard-quit)
     (define-key minibuffer-local-completion-map [escape] 'nox/minibuffer-keyboard-quit)
     (define-key minibuffer-local-must-match-map [escape] 'nox/minibuffer-keyboard-quit)
     (define-key minibuffer-local-isearch-map [escape] 'nox/minibuffer-keyboard-quit)

     ;; Unimpaired.vim
     (define-key evil-normal-state-map (kbd "[ SPC")
       (lambda () (interactive) (evil-insert-newline-above) (forward-line)))
     (define-key evil-normal-state-map (kbd "] SPC")
       (lambda () (interactive) (evil-insert-newline-below) (forward-line -1)))
     (define-key evil-normal-state-map (kbd "[ e") (kbd "ddkP"))
     (define-key evil-normal-state-map (kbd "] e") (kbd "ddp"))
     (define-key evil-normal-state-map (kbd "[ b") 'previous-buffer)
     (define-key evil-normal-state-map (kbd "] b") 'next-buffer)

     ;; Emacs Lisp
     (evil-leader/set-key-for-mode 'emacs-lisp-mode "C" 'byte-compile-file)
     (evil-leader/set-key-for-mode 'emacs-lisp-mode "E" 'eval-buffer)
     (evil-leader/set-key-for-mode 'emacs-lisp-mode "e" 'eval-defun)
     (evil-leader/set-key-for-mode 'emacs-lisp-mode "x" 'eval-last-sexp)

     ;; Smartparens manipulations
     ;; See all of them here:
     ;; https://github.com/Fuco1/smartparens/wiki/Working-with-expressions
     (evil-define-key 'normal emacs-lisp-mode-map
       (kbd "C-S-k") 'sp-split-sexp
       (kbd "C-S-j") 'sp-join-sexp
       (kbd "C-S-l") 'sp-forward-slurp-sexp
       (kbd "C-S-h") 'sp-backward-slurp-sexp
       (kbd "C-M-l") 'sp-forward-barf-sexp
       (kbd "C-M-h") 'sp-backward-barf-sexp)
   #+END_SRC

* Editing

** Utilities

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package surround
       :init (global-surround-mode 1))

     (use-package ace-jump-mode
       :commands ace-jump-mode
       :init
       (define-key evil-normal-state-map (kbd "SPC") 'ace-jump-mode))

     (use-package smartparens-config
       :init (smartparens-global-mode t)
       :config
       (progn
         ;; Fix handling of {} and [] when hitting RET inside
         (defun nox/sp/pair-on-newline (id action context)
           "Put trailing pair on newline and return to point."
           (save-excursion
             (newline)
             (indent-according-to-mode)))

         (defun nox/sp/pair-on-newline-and-indent (id action context)
           "Open a new brace or bracket expression, with relevant newlines and indent. "
           (nox/sp/pair-on-newline id action context)
           (indent-according-to-mode))

         (sp-pair "{" nil :post-handlers
                  '(:add ((lambda (id action context)
                            (nox/sp/pair-on-newline-and-indent id action context)) "RET")))
         (sp-pair "[" nil :post-handlers
                  '(:add ((lambda (id action context)
                            (nox/sp/pair-on-newline-and-indent id action context)) "RET")))))

     ;; Use UTF-8
     (set-default-coding-systems 'utf-8-unix)
     (set-terminal-coding-system 'utf-8-unix)
     (set-keyboard-coding-system 'utf-8-unix)
     (prefer-coding-system 'utf-8-unix)

     (defun nox/write-file-copy (filename)
       (interactive "F")
       (save-restriction (widen)
                         (write-region (point-min) (point-max) filename)))

     (defun nox/write-timestamped-file-copy (filename)
       (interactive "F")
       (let ((timestamp (format-time-string "%Y%m%d-%H%M%S"))
             (filename-head (file-name-sans-extension filename))
             (filename-ext (file-name-extension filename t)))
         (nox/write-file-copy (expand-file-name (concat filename-head "_" timestamp filename-ext)))))

     (defun nox/write-timestamped-current-file-copy ()
       (interactive)
       (nox/write-timestamped-file-copy (buffer-file-name)))
   #+END_SRC

** Scrolling

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq scroll-conservatively 999        ; Never recenter the window on the cursor
           mouse-wheel-scroll-amount '(1))  ; Slower mouse wheel/trackpad scrolling
   #+END_SRC

** Whitespace and Formatting

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq-default indent-tabs-mode nil)

     (setq require-final-newline t) ; auto-insert final newlines in all files

     (use-package whitespace
       :commands (whitespace-cleanup
                  whitespace-mode)
       :init
       (progn
         (evil-leader/set-key "W"   'whitespace-cleanup)
         (evil-leader/set-key "col" 'whitespace-mode))
       :config
       (progn
         (setq whitespace-line-column 110) ; TODO: only apply to HTML
         (setq whitespace-style '(face
                                  tabs
                                  spaces
                                  trailing
                                  lines-tail
                                  space-before-tab
                                  newline
                                  indentation
                                  empty
                                  space-after-tab
                                  space-mark
                                  tab-mark
                                  newline-mark))))

     (defun nox/indent-buffer ()
             (interactive)
             (save-excursion
                     (indent-region (point-min) (point-max) nil)))

     (defun nox/show-trailing-whitespace ()
             (interactive)
             (setq show-trailing-whitespace t))

     (add-hook 'prog-mode-hook 'nox/show-trailing-whitespace)
   #+END_SRC

** Spelling

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; Use aspell for spell checking: brew install aspell --lang=en
     (setq ispell-program-name "/usr/local/bin/aspell")
     (add-hook 'text-mode-hook 'flyspell-mode)
     (add-hook 'prog-mode-hook 'flyspell-prog-mode)
   #+END_SRC

** Syntax Checking

   Use [[https://github.com/flycheck/flycheck][Flycheck]] to validate syntax on the fly.

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package flycheck
       :init
       (progn
         (global-flycheck-mode 1)))
   #+END_SRC

** Emacs-Lisp

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package emacs-lisp-mode
       :init
       (use-package eldoc
         :init (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode))
       :mode ("Cask" . emacs-lisp-mode))

     (defun nox/byte-recompile ()
       "`byte-compile' every .el file under `user-emacs-directory' recursively"
       (interactive)
       (byte-recompile-directory user-emacs-directory 0)
       (when (fboundp 'sauron-add-event)
           (sauron-add-event 'editor 2 "Byte compiled Emacs directory")))

     (defun nox/byte-compile-current-buffer ()
       "`byte-compile' current buffer in emacs-lisp-mode if compiled file exists."
       (interactive)
       (when (and (eq major-mode 'emacs-lisp-mode)
                  (file-exists-p (byte-compile-dest-file buffer-file-name)))
         (byte-compile-file buffer-file-name)
         (when (fboundp 'sauron-add-event)
           (sauron-add-event 'editor 2 "Byte compiled buffer"))))

     (add-hook 'after-save-hook 'nox/byte-compile-current-buffer)
   #+END_SRC

** Ruby

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package ruby-mode
       :mode (("\\.rake$" . ruby-mode)
              ("\\.gemspec$" . ruby-mode)
              ("\\.ru$" . ruby-mode)
              ("Rakefile$" . ruby-mode)
              ("Gemfile$" . ruby-mode)
              ("Capfile$" . ruby-mode)
              ("Guardfile$" . ruby-mode)))
   #+END_SRC

** Snippets

   Use [[https://github.com/capitaomorte/yasnippet][YASnippet]] for snippets:

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package yasnippet
       :init
       (progn
         (yas-global-mode t)

         ;; Suppress excessive log messages
         (setq yas-verbosity 1)))
   #+END_SRC

** Expansion

   Use [[http://www.gnu.org/software/emacs/manual/html_node/autotype/Hippie-Expand.html][hippie-expand]] for inline expansion in all modes:

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (global-set-key (kbd "M-/") 'hippie-expand)
   #+END_SRC

* Navigation and Completion

** Ido

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package ido
       :init
       (progn
         (ido-mode t)
         (ido-everywhere t)
         (ido-ubiquitous-mode t))

       :config
       (progn
         (setq ido-enable-flex-matching t)
         (add-to-list 'ido-ignore-files "\\.DS_Store")

         (use-package ido-vertical-mode
           :init
           (ido-vertical-mode))))
   #+END_SRC

** Smex

   Smex provides Ido completion for ~M-x~.

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package smex
       :bind (("M-x" . smex)
              ("M-X" . smex-major-mode-commands))
       :init
       (progn
         (setq smex-save-file (expand-file-name "smex-items" nox/ephemeral-directory))
         (setq smex-history-length 10)
         (setq smex-flex-matching t)
         (smex-initialize)))
   #+END_SRC

** Buffers

   For more intensive buffer switching and buffer management, use ~ibuffer~:

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package ibuffer
       :commands ibuffer
       :init
       (progn
         (setq ibuffer-saved-filter-groups
               (quote (("default"
                        ("Config" (or
                                   (filename . ".dots/")
                                   (filename . ".emacs.d/")))
                        ("Shell"  (or
                                   (mode . eshell-mode)
                                   (mode . shell-mode)))
                        ("Dired"  (mode . dired-mode))
                        ("Prose"  (or
                                   (mode . tex-mode)
                                   (mode . plain-tex-mode)
                                   (mode . latex-mode)
                                   (mode . rst-mode)
                                   (mode . markdown-mode)))
                        ("Org"    (mode . org-mode))
                        ("Gnus"   (or
                                   (mode . message-mode)
                                   (mode . gnus-group-mode)
                                   (mode . gnus-summary-mode)
                                   (mode . gnus-article-mode)))
                        ("Emacs"  (name . "^\\*.*\\*$"))
                        )
                       ("projects"
                        ("Thesis" (filename . "~/thesis/"))
                        ))))

         (add-hook 'ibuffer-mode-hook
                   (lambda ()
                     (ibuffer-switch-to-saved-filter-groups "default")))

         (setq ibuffer-expert t)
         (setq ibuffer-show-empty-filter-groups nil)))
   #+END_SRC

   Clean up buffers periodically:

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package midnight)
   #+END_SRC

** Helm

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package helm-config)
   #+END_SRC

** Project Management

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package project-persist
       :init (project-persist-mode t)
       :config
       (progn
         ;;; The following was yanked from Graphene:
         (defun kill-buffer-if-file (buf)
           "Kill a buffer only if it is file-based."
           (when (buffer-file-name buf)
             (when (buffer-modified-p buf)
               (when (y-or-n-p (format "Buffer %s is modified - save it?" (buffer-name buf)))
                 (save-some-buffers nil buf)))
             (set-buffer-modified-p nil)
             (kill-buffer buf)))

         (defun kill-all-buffers ()
           "Kill all file-based buffers."
           (interactive)
           (mapc (lambda (buf) (kill-buffer-if-file buf))
                 (buffer-list)))

         (defun graphene-set-project-root (dir)
           "Change the default directory and update speedbar if used."
           (setq default-directory dir))

         (defun graphene-load-project-desktop ()
           "Load the project's desktop if available."
           (ignore-errors
             (setq default-directory project-persist-current-project-settings-dir)
             (message (format "Loading project desktop from %s" default-directory))
             (desktop-read project-persist-current-project-settings-dir)))

         ;; Kill all file-based buffers and unpin the speedbar before opening a project.
         (add-hook 'project-persist-before-load-hook
                   (lambda ()
                     (kill-all-buffers)))

         ;; Kill all file-based buffers and unpin the speedbar after closing a project.
         (add-hook 'project-persist-after-close-hook
                   (lambda ()
                     (kill-all-buffers)))

         ;; Set the project root directory, load the project desktop and update speedbar.
         (add-hook 'project-persist-after-load-hook
                   (lambda ()
                     (graphene-load-project-desktop)
                     (graphene-set-project-root project-persist-current-project-root-dir)))

         ;; Save the project desktop.
         (add-hook 'project-persist-after-save-hook
                   (lambda ()
                     (message (format "Saving project desktop in %s" project-persist-current-project-settings-dir))
                     (desktop-save project-persist-current-project-settings-dir)))))

     ;; http://www.emacswiki.org/DeskTop#toc4: Overriding stale desktop locks
     ;;; desktop-override-stale-locks.el begins here
     (defun emacs-process-p (pid)
       "If pid is the process ID of an emacs process, return t, else nil.
     Also returns nil if pid is nil."
       (when pid
         (let ((attributes (process-attributes pid)) (cmd))
           (dolist (attr attributes)
             (if (string= "comm" (car attr))
                 (setq cmd (cdr attr))))
           (if (and cmd (or (string= "emacs" cmd) (string= "emacs.exe" cmd))) t))))

     (defadvice desktop-owner (after pry-from-cold-dead-hands activate)
       "Don't allow dead emacsen to own the desktop file."
       (when (not (emacs-process-p ad-return-value))
         (setq ad-return-value nil)))
     ;;; desktop-override-stale-locks.el ends here
   #+END_SRC

** Find in Project

   [[https://github.com/bbatsov/projectile][Projectile]] allows easy switching between projects as well as
   finding files and buffers related to the current project, however
   it does not implement its own interface, instead leveraging Ido,
   Helm, or Grizzl.

   Projectile's bindings start with ~C-c p~.

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package projectile
       :init
       (progn
         (setq projectile-show-paths-function 'projectile-hashify-with-relative-paths)

         ;; TODO: This can probably be done more elegantly with :bind
         (define-key projectile-mode-map [?\s-f] 'projectile-find-file)
         (define-key projectile-mode-map [?\s-b] 'projectile-switch-to-buffer)
         (define-key projectile-mode-map [?\s-k] 'projectile-kill-buffers)
         (define-key projectile-mode-map [?\s-d] 'projectile-find-dir)
         (define-key projectile-mode-map [?\s-D] 'projectile-dired)
         (define-key projectile-mode-map [?\s-g] 'projectile-grep)
         (define-key projectile-mode-map [?\s-p] 'projectile-switch-project)

         (projectile-global-mode)))
   #+END_SRC

   [[https://github.com/d11wtq/fiplr][Fiplr]] is a minimalistic Find in Project package that uses fuzzy
   matching. Its function overlaps with Projectile considerably, but
   it is more flexible about what a project means.

   It serves to replace =ido-find-file=.

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package fiplr
       :commands (fiplr-find-file fiplr-find-directory)
       :config (setq fiplr-root-markers '(".git"
                                          ".svn"
                                          ".hg"
                                          ".bzr"
                                          ".projectile"
                                          "Cask"
                                          "Gemfile"
                                          "Makefile"
                                          "Rakefile")))
   #+END_SRC

** Auto-completion

   Use [[http://cx4a.org/software/auto-complete/index.html][Auto Complete Mode]] for inline completion in certain major modes:

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package auto-complete-config
       :init
       (progn
         (use-package pos-tip)

         (add-to-list 'ac-dictionary-directories (expand-file-name "ac-dict" user-emacs-directory))
         ;; User-defined dictionary goes in "~/.dict" by default.

         ;; The default value of ac-sources is
         ;; '(ac-source-abbrev ac-source-dictionary ac-source-words-in-same-mode-buffers)
         ;; and then this is overridden for a handful of major modes.
         ;;
         ;; Add a couple of non-default sources to ac-sources for all buffers
         ;; by redefining this function called from (ac-config-default):
         (defun ac-common-setup ()
           (setq ac-sources (append ac-sources '(ac-source-yasnippet
                                                 ac-source-filename))))

         (setq ac-comphist-file (expand-file-name "ac-comphist.dat" nox/ephemeral-directory))
         (setq ac-auto-start 1) ; Number of characters typed before completion starts

         (ac-config-default)
         (ac-flyspell-workaround)
         (ac-linum-workaround)))
   #+END_SRC

** Key Bindings

   Completion of sorts for key sequences is provided by [[https://github.com/kbkbkbkb1/guide-key][guide-key]]:

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package guide-key
       :init
       (progn
         (guide-key-mode 1))
       :config
       (progn
         (setq guide-key/recursive-key-sequence-flag t
               guide-key/align-command-by-space-flag t
               guide-key/popup-window-position 'bottom)

         ;; Sequences of interest globally
         (setq guide-key/guide-key-sequence '("C-x r"
                                              "C-x 4"   ; Other window commands
                                              "C-x 5"   ; Other frame commands
                                              "C-x c"   ; Helm prefix
                                              "C-c p"   ; Projectile prefix
                                              "C-c P")) ; Project-persist prefix

         ;; Sequences of interest for specific modes
         (defun guide-key/my-hook-function-for-org-mode ()
           (guide-key/add-local-guide-key-sequence "C-c")
           (guide-key/add-local-guide-key-sequence "C-c C-x")
           (guide-key/add-local-highlight-command-regexp "org-"))
         (add-hook 'org-mode-hook 'guide-key/my-hook-function-for-org-mode)))
   #+END_SRC

* Org

** Basic Settings

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'org)
     (use-package evil-org)

     ;; http://orgmode.org/worg/org-contrib/org-mac-message.html
     (add-to-list 'org-modules 'org-mac-message)

     ;; Track habits
     (add-to-list 'org-modules 'org-habit)
     (use-package org-habit
       :config
       (setq org-habit-show-habits-only-for-today nil))

     (setq org-directory "~/org")
     (setq org-default-notes-file (expand-file-name "agenda.org" org-directory))

     ;; http://lists.gnu.org/archive/html/emacs-orgmode/2013-02/msg00644.html
     (org-agenda-to-appt)             ;; generate the appt list from org agenda files on emacs launch
     (run-at-time "24:01" 3600 'org-agenda-to-appt)           ;; update appt list hourly
     (add-hook 'org-finalize-agenda-hook 'org-agenda-to-appt) ;; update appt list on agenda view

     (setq org-capture-templates
           (quote (("t" "To-do" entry
                    (file+headline "" "Inbox")
                    "* TODO %u %^{Task}"
                    :clock-keep t :kill-buffer t)
                   ("d" "To-do (done)" entry
                    (file+headline "" "Inbox")
                    "* DONE %u %^{Task}"
                    :clock-keep t :kill-buffer t)
                   ("q" "Quick to-do" entry
                    (file+headline "" "Inbox")
                    "* TODO %^{Task}\n  SCHEDULED: %t"
                    :clock-keep t :kill-buffer t :immediate-finish t)
                   ("s" "Timeslip" entry
                    (file+olp (expand-file-name "bigtech.org" org-directory) "Unfiled")
                    "* TODO %i%?\n  DEADLINE: %^{Due}t\n%^{Cost}p\n%^{Billable}"
                    :clock-keep t :kill-buffer t))))

     (setq org-goto-interface (quote outline-path-completion))
     (setq org-log-done (quote time))
     (setq org-log-into-drawer t)
     (setq org-refile-allow-creating-parent-nodes (quote confirm))
     (setq org-refile-use-outline-path t)
     (setq org-return-follows-link t)
     (setq org-catch-invisible-edits (quote show-and-error))

     (setq org-todo-keywords '((sequence
                               "TODO(t)"
                               "STARTED(s!)"
                               "WAITING(w@/!)"
                               "|"
                               "CANCELED(c@)"
                               "DONE(d!)"
                               )))

     (setq org-hide-leading-stars t)

     ;; Code blocks
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (sh . t)))
     (setq org-src-fontify-natively t)
     (setq org-src-tab-acts-natively t)
   #+END_SRC

** Templates

Org mode provides a mechanism for inserting [[http://orgmode.org/manual/Easy-Templates.html][templates]] into Org
documents. To insert a structural element, type a ~<~, followed by a
template selector and ~<TAB>~.

** Tags

   Org headlines can be tagged such that they are easier to find and
   filter. Here we set up reusable tags with mnemonic shortcuts.

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq org-tag-alist '(("@work" . ?W)     ; Contexts
                           ("@home" . ?H)
                           ("@school" . ?S)
                           ("@errand" . ?E)
                           ("build" . ?b)     ; Task types
                           ("earn" . ?e)
                           ("learn" . ?l)
                           ("focus" . ?f)     ; Task statuses
                           ("someday" . ?s)
                           ("delegate" . ?d)))
   #+END_SRC

** Exporting

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq org-hide-emphasis-markers t
           org-export-with-section-numbers nil
           org-export-html-preamble nil
           org-export-html-postamble nil
           org-export-html-style "<link rel=\"stylesheet\" type=\"text/css\" href=\"org.css\" />")
   #+END_SRC

** Key Bindings

#+INCLUDE: "org_key_bindings.org"

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
   ;; Org mode - http://orgmode.org/guide/Activation.html#Activation
   (global-set-key (kbd "C-c c") 'org-capture)
   (global-set-key (kbd "C-c l") 'org-store-link)
   (global-set-key (kbd "C-c a") 'org-agenda)
   (global-set-key (kbd "C-c b") 'org-iswitchb)

   (eval-after-load 'org-agenda
     '(progn
        ;; Use the standard Org agenda bindings as a base
        (evil-make-overriding-map org-agenda-mode-map 'emacs t)
        (evil-add-hjkl-bindings org-agenda-mode-map 'emacs
          (kbd "C-j") 'org-agenda-goto-date))) ; "j"
   #+END_SRC

** Clocking Time

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package org-clock
       :init
       (progn
         (setq org-clock-persist-file (expand-file-name ".org-clock-save.el" org-directory)
               org-clock-persist t
               ;; Do not prompt to resume an active clock
               ;org-clock-persist-query-resume nil
               ;; Resume clocking task on clock-in if the clock line is open
               org-clock-in-resume t
               org-clock-in-switch-to-state "STARTED"
               org-clock-out-remove-zero-time-clocks t
               org-clock-out-when-done t
               org-clock-idle-time 20
               ;; Include current clocking task in clock reports
               org-clock-report-include-clocking-task t)

         ;; Resume clocking tasks when emacs is restarted
         (org-clock-persistence-insinuate)))
   #+END_SRC

** Agenda

*** Basic Configuration

    #+NAME: org
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package org-agenda)

      (setq org-agenda-files '("~/org")
            org-agenda-skip-unavailable-files t
            org-agenda-skip-deadline-if-done nil
            org-agenda-skip-scheduled-if-done nil
            org-agenda-restore-windows-after-quit t
            org-agenda-window-setup 'other-window
            org-agenda-show-all-dates t
            org-agenda-show-log t
            org-agenda-diary-file (expand-file-name "diary.org" org-directory)
            org-agenda-include-diary t)
    #+END_SRC

*** Custom Agenda Commands

    Below are our custom agenda commands:

    | Key | Description                                   |
    |-----+-----------------------------------------------|
    | ~d~   | Timeline for today, including a clock summary |
    | ~w~   | Items with status WAITING                     |
    | ~U~   | Important tasks that I might tend to avoid    |
    | ~P~   | Items by priority                             |

    #+NAME: org
    #+BEGIN_SRC emacs-lisp :tangle no
      (setq org-agenda-custom-commands
            `(("d" "Timeline for today" ((agenda "" ))
               ((org-agenda-ndays 1)
                (org-agenda-show-log t)
                (org-agenda-log-mode-items '(clock closed))
                (org-agenda-clockreport-mode t)
                (org-agenda-entry-types '())))
              ("w" "Waiting for" todo "WAITING"
               ((org-agenda-sorting-strategy '(priority-down))))
              ("U" "Important stuff I don't want to do"
               ((tags-todo "focus")))
              ("P" "By priority"
               ((tags-todo "+PRIORITY=\"A\"")
                (tags-todo "+PRIORITY=\"B\"")
                (tags-todo "+PRIORITY=\"\"")
                (tags-todo "+PRIORITY=\"C\""))
               ((org-agenda-prefix-format "%-10c %-10T %e ")
                (org-agenda-sorting-strategy '(priority-down tag-up category-keep effort-down))))))
    #+END_SRC

*** Automatically Show Agenda

    I tend not to consult the agenda often enough, so let's show it
    after Emacs is idle for a while.

   #+NAME: org
    #+BEGIN_SRC emacs-lisp :tangle no
      (defun nox/jump-to-org-agenda ()
        (interactive)
        (let ((buf (get-buffer "*Org Agenda*"))
              wind)
          (if buf
              (if (setq wind (get-buffer-window buf))
                  (select-window wind)
                (if (called-interactively-p)
                    (progn
                      (select-window (display-buffer buf t t))
                      (org-fit-window-to-buffer))
                  (with-selected-window (display-buffer buf)
                    (org-fit-window-to-buffer))))
            (call-interactively 'org-agenda-list))))

      (run-with-idle-timer 1200 t 'nox/jump-to-org-agenda)
    #+END_SRC

** Appointments

   Use the ~appt~ package for displaying appointment alerts. The
   following was derived from [[http://lists.gnu.org/archive/html/emacs-orgmode/2013-02/msg00644.html][this message]] on the Org mode mailing
   list.

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package appt
       :init
       (progn
         (setq appt-message-warning-time '30) ;; Send first warning 30 minutes before appointment
         (setq appt-display-interval '15)     ;; Warn every 15 minutes from appt-message-warning-time
         (appt-activate 1)))                  ;; Activate appointment notification
   #+END_SRC

** Mobile

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package org-mobile
       :init
       (progn
         ;; Set to the name of the file where new notes will be stored
         (setq org-mobile-inbox-for-pull (expand-file-name "mobile-flagged.org" org-directory)
               org-mobile-directory "~/Dropbox/Apps/MobileOrg"
               org-mobile-agendas '("a")
               org-mobile-force-id-on-agenda-items nil
               ;; org-mobile-encryption-password is set in private.el
               org-mobile-use-encryption t)

         (defvar nox/org-mobile-sync-timer nil)
         (defvar nox/org-mobile-sync-secs (* 60 20))

         (defun nox/org-mobile-sync-pull-and-push ()
           (org-mobile-pull)
           (org-mobile-push)
           (when (fboundp 'sauron-add-event)
             (sauron-add-event 'org-mobile 3 "Finished MobileOrg sync")))

         (defun nox/org-mobile-sync-start ()
           "Start automated `org-mobile-push'"
           (interactive)
           (setq nox/org-mobile-sync-timer
                 (run-with-idle-timer nox/org-mobile-sync-secs t
                                      'nox/org-mobile-sync-pull-and-push)))

         (defun nox/org-mobile-sync-stop ()
           "Stop automated `org-mobile-push'"
           (interactive)
           (cancel-timer nox/org-mobile-sync-timer))

         (add-hook 'after-init-hook 'nox/org-mobile-sync-start)
         (add-hook 'kill-emacs-hook 'org-mobile-push)))
   #+END_SRC

** TeamworkPM Integration

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar twpm-executable-path "~/bin/twpm")

     (defun nox/twpm-timelog (task-id date time hours minutes)
       "Call twpm script with parameters, allowing you to submit time-tracking info
     to the TeamworkPM API."
       (shell-command (format "%s --task-id=%s --date=%s --time=%s --hours=%s --minutes=%s"
                      twpm-executable-path
                      task-id
                      date
                      time
                      hours
                      minutes))
       (message (format "Task %s: submitted %s:%s for %s"
                        task-id
                        hours
                        minutes
                        date)))

     (defun nox/twpm-timelog-get-clock-table-date ()
       (save-excursion
         (re-search-backward "^Daily report: \\[\\([0-9-]+\\) ")
         (match-string 1)))

     (defun nox/twpm-timelog-get-clock-table-row-id ()
       (save-excursion
         (beginning-of-line)
         (re-search-forward "^| +| +\\([0-9]+\\) +|")
         (match-string 1)))

     (defun nox/twpm-timelog-get-clock-table-row-hours ()
       (save-excursion
         (beginning-of-line)
         (re-search-forward "| +\\([0-9]+\\):[0-9]+ |$")
         (match-string 1)))

     (defun nox/twpm-timelog-get-clock-table-row-minutes ()
       (save-excursion
         (beginning-of-line)
         (re-search-forward "| +[0-9]+:\\([0-9]+\\) |$")
         (match-string 1)))

     (defun nox/twpm-timelog-from-clock-table ()
       "With the point placed on an org-mode clock table row, submit the time to the
     TeamworkPM API. Note that this only works on clock tables with step: day."
       (interactive)
       (let ((task-id (nox/twpm-timelog-get-clock-table-row-id))
             (date (nox/twpm-timelog-get-clock-table-date))
             (time "00:00")
             (hours (nox/twpm-timelog-get-clock-table-row-hours))
             (minutes (nox/twpm-timelog-get-clock-table-row-minutes)))
         (nox/twpm-timelog task-id date time hours minutes)))
   #+END_SRC

** Invoicing

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar invoice-dir "~/Documents/Invoices/")
     (defvar invoice-template-path (expand-file-name "_template.org" invoice-dir))

     (defun nox/invoice-next-number ()
       "Get next sequential invoice number. Invoice numbers are in the format YYYYXXX,
     where YYYY is the current year and XXX is a zero-padded sequential counter
     modulo 1000. Ex.: 2016001."
       (concat (format-time-string "%Y" (current-time))
               (format "%03d" (% (1+ (string-to-number
                                   (substring (car (last (directory-files
                                           invoice-dir
                                           nil
                                           "^[0-9]+\.org$"))) 4 7))) 1000))))

     (defun nox/invoice-get-path (number)
       "Derive invoice file path from invoice NUMBER."
       (format "%s/%s.org" invoice-dir number))

     (defun nox/invoice-create (scope-file)
       "Make a new invoice from given file and date range."
       (interactive "forg file: ")
       (let ((invoice-number (nox/invoice-next-number))
             (invoice-date (format-time-string "%m/%d/%Y" (current-time)))
             (invoice-start (org-read-date nil t nil "Choose invoice start" nil "-2Mon"))
             (invoice-end (org-read-date nil nil nil "Choose invoice end" nil "-Sun")))
         (find-file (nox/invoice-get-path invoice-number))
         (insert-file-contents invoice-template-path)
         (goto-char (point-min))
         (while (search-forward "@INVOICE_NUMBER@" nil t)
           (replace-match invoice-number))
         (goto-char (point-min))
         (while (search-forward "@SCOPE_FILE@" nil t)
           (replace-match scope-file))
         (org-update-all-dblocks)))

     (defun nox/invoice-create-from-current-buffer-file ()
       "Make a new invoice from current buffer's file and given date range."
       (interactive)
       (nox/invoice-create (buffer-file-name)))
   #+END_SRC

* Notifications

** Terminal Notifier

   #+NAME: notifications
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar nox/notifier-path
       "/usr/local/bin/terminal-notifier")

     (defun nox/send-notification (title msg &optional group)
       (let ((group (if group (format " -group %s" group)))
             (msg (format " -message '%s'" msg))
             (title (format " -title '%s'" title))
             (sender " -sender org.gnu.Emacs"))
         (shell-command (concat nox/notifier-path
                                msg
                                title
                                sender
                                group))))
   #+END_SRC

** Alert

   #+NAME: notifications
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package alert
       :config
       (progn
         (setq alert-default-style 'terminal-notifier)

         (alert-define-style 'terminal-notifier :title "Terminal Notifier"
                             :notifier
                             (lambda (info)
                               (nox/send-notification
                                (plist-get info :title)
                                (plist-get info :message)
                                (plist-get info :category))))))
   #+END_SRC

** Sauron

   #+NAME: notifications
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package sauron
       :config
       (progn
         ;; Pass notifications through to alert.el
         (add-hook 'sauron-event-added-functions 'sauron-alert-el-adapter)

         ;; Show in a split rather than a separate frame
         (setq sauron-separate-frame nil
               sauron-hide-mode-line t)

         (global-set-key (kbd "C-c s") 'sauron-toggle-hide-show)
         (global-set-key (kbd "C-c t") 'sauron-clear)))
   #+END_SRC

* Configuration Layout

  Here we define the ~emacs.el~ file that gets generated by the source
  blocks in our Org document:

  #+BEGIN_SRC emacs-lisp :tangle yes :noweb no-export :exports code
    ;;; emacs.el --- Emacs configuration generated via Org Babel

    ;;; Commentary:

    ;; Do not modify this file by hand.  It was automatically generated
    ;; from `emacs.org` in the same directory.  See that file for more
    ;; information.

    ;;; Code:

    ;; Configuration group: init-before
    <<init-before>>

    ;; Configuration group: appearance
    <<appearance>>

    ;; Configuration group: evil
    <<evil>>

    ;; Configuration group: editing
    <<editing>>

    ;; Configuration group: navigation-completion
    <<navigation-completion>>

    ;; Configuration group: org
    <<org>>

    ;; Configuration group: notifications
    <<notifications>>

    ;; Configuration group: init-after
    <<init-after>>

    ;; emacs.el ends here
  #+END_SRC

* Wish List

  Functionality I want or things that need to be fixed:

  - Feature: Pressing ~Tab~ in a *Help* buffer jumps to the next link
  - Feature: Pressing ~C-w~ in minibuffer deletes word backward
  - Feature: Evil bindings in package listings
  - Fix: don't remap ~h~ and ~l~ in Org agenda buffer, move old ~j~ and ~k~ to ~n~ and ~p~
  - Fix: figure out how to create normal-state mapping that starts with ~c~
  - Use Emacs for RSS. =newsticker.el= seemed promising, but it
    caused Emacs to hang on startup while it fetched feeds and it
    couldn't handle half the feeds for some reason. =elfeed.el= was
    overly complicated and also couldn't handle some feeds. Gnus is
    ridiculous.
