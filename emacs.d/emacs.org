#+TITLE: Nox's Emacs Configuration
#+AUTHOR: Noah Frederick

* Usage

** Obtaining the Source

   You can find the latest version of the configuration in [[https://github.com/noahfrederick/dots][the GitHub
   repository]]. The meat of it (and the source of this document) is the
   ~emacs.org~ file.

** Installation

   This configuration is intended to be installable from scratch. It
   uses [[https://github.com/cask/cask][Cask]] to specify the package dependencies. [[https://github.com/rdallasgray/pallet][Pallet]] allows us to
   use Cask in conjunction with ~package.el~ such that our ~Cask~ file is
   kept up to date when we add and remove packages.

  - Install GNU Emacs 24 or later
  - Install Cask from https://github.com/cask/cask
  - Run ~cask install~ in ~$HOME/.emacs.d~

** Commentary

   Any variables, functions, or macros defined in this configuration
   are "namespaced" with a prefix of =nox/=. This is only a convention
   for easily distinguishing between built-in functions and those
   defined in this configuration or another package, and has no other
   special significance.

** Configuring Packages

   We use [[https://github.com/jwiegley/use-package][use-package]] to autoload packages. It provides a DSL for
   setting up autoloads and keybindings, and for deferring the loading
   of packages that might otherwise slow down Emacs's startup.

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'use-package)
   #+END_SRC

** Benchmarking

   It's useful to measure how long it takes Emacs to start up, so
   let's show the total time in a message:

   #+NAME: init-after
   #+BEGIN_SRC emacs-lisp :tangle no :tangle no
     (defun nox/show-startup-time ()
       "Show Emacs's startup time in the minibuffer"
       (message "Startup time: %s seconds."
                (emacs-uptime "%s")))

     (add-hook 'emacs-startup-hook 'nox/show-startup-time 'append)
   #+END_SRC

* Emacs Initialization

** Paths

   Keep any Elisp files not installed from a package repository in the
   ~vendor/~ directory:

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar nox/vendor-directory (concat user-emacs-directory "vendor/"))
     (add-to-list 'load-path nox/vendor-directory)
   #+END_SRC

   Keep theme files in the ~themes/~ directory:

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq custom-theme-directory (concat user-emacs-directory "themes/"))
   #+END_SRC

   Keep temporary files in a separate directory:

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar nox/ephemeral-directory "~/.emacs.ephemeral/")
     (unless (file-exists-p nox/ephemeral-directory)
       (mkdir nox/ephemeral-directory))
   #+END_SRC

** Platform-specific

   There are a few settings that are only relevant to OS X (Darwin):

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (cond ((eq system-type 'darwin)
            (setq delete-by-moving-to-trash t
                  trash-directory "~/.Trash/")
            ;; BSD ls does not support --dired. Use GNU core-utils: brew install coreutils
            (when (executable-find "gls")
              (setq insert-directory-program "gls"))
            ;; Derive PATH by running a shell so that GUI Emacs sessions have access to it
            (exec-path-from-shell-initialize)
            ;; Correctly parse exec-path when PATH delimiter is a space
            (when (equal (file-name-nondirectory (getenv "SHELL")) "fish")
              (setq exec-path (split-string (car exec-path) " "))
              (setenv "PATH" (mapconcat 'identity exec-path ":")))))
   #+END_SRC

** Start Server

   The Emacs server allows for using ~emacsclient~ to quickly pop open a
   new frame in a terminal:

   #+NAME: init-after
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package server
       :init
       (unless (server-running-p)
         (server-start)))
   #+END_SRC

   Here are the most common ways in which ~emacsclient~ is used:

   | Command                         | Description                     |
   |---------------------------------+---------------------------------|
   | ~emacsclient~                     | Edit in existing frame          |
   | ~emacsclient -n (--no-wait)~      | Do not wait--return immediately |
   | ~emacsclient -c (--create-frame)~ | Edit in a new frame             |
   | ~emacsclient -t (--tty)~          | Edit in a new terminal frame    |
   | ~emacsclient -e (--eval)~         | Evaluate the following Elisp    |

   For more, see ~man emacsclient~.

** Temporary Files

   #+NAME: init-after
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq backup-directory-alist
           `((".*" . ,temporary-file-directory)))
     (setq auto-save-file-name-transforms
           `((".*" ,temporary-file-directory t)))
     (setq-default make-backup-files nil)
   #+END_SRC

** Private

   Since this configuration is kept in version control in public view,
   we keep sensitive information such as passwords in a separate
   file. Anything with the special prefix =nox/private/= originates from
   this file.

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar nox/private-file (expand-file-name "private.el" user-emacs-directory))
     (load nox/private-file 'noerror)
   #+END_SRC

** Custom

   Set alternative location for ~custom-set-variables~ and ~custom-set-faces~:

   #+NAME: init-after
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (load custom-file 'noerror)
   #+END_SRC

* Appearance

** UI

   Hide parts of the GUI that we don't need, namely the graphical tool
   bar and any scroll bars.

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
     (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
   #+END_SRC

   Load the theme, which determines colors and font variants. Enox is
   a medium-contrast theme with a dark background.

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (load-theme 'enox t)
   #+END_SRC

   We also set the font while specifying a couple fallbacks. The last
   argument of =set-frame-font= ensures that new frames inherit the font
   as well.

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (cond
      ((find-font (font-spec :name "Source Code Pro"))
       (set-frame-font "Source Code Pro-14" t t))
      ((find-font (font-spec :name "Panic Sans"))
       (set-frame-font "Panic Sans-14" t t))
      ((find-font (font-spec :name "courier"))
       (set-frame-font "courier-14" t t)))
   #+END_SRC

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (global-hl-line-mode)

     ;; The developer build of Emacs Trunk has a function called
     ;; toggle-frame-maximized, which is included within
     ;; .../lisp/frame.el. That function can be added to the
     ;; after-init-hook or emacs-startup-hook, or simply included in the
     ;; .emacs file that gets loaded on startup. On OSX, it increases
     ;; both width and height in one-fell-swoop.
     ;;
     ;; Source: http://stackoverflow.com/a/18711628
     (if (fboundp 'toggle-frame-maximized)
         (add-hook 'emacs-startup-hook 'toggle-frame-maximized))

     ;; Set up terminal frames appropriately
     (defun nox/after-make-frame (frame)
       (unless (display-graphic-p frame)
         (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
         (set-face-background 'default "dummy-color" frame)))

     (add-hook 'after-make-frame-functions 'nox/after-make-frame)

     (setq ring-bell-function 'ignore)
     (setq inhibit-startup-screen t)

     ;; Set message for *scratch* buffer
     (setq initial-scratch-message ";; Hello, Nox.\n")

     ;; Use ANSI color in shell
     (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

     ;; Never require full word answers
     (defalias 'yes-or-no-p 'y-or-n-p)

     (setq linum-format "%4d ")
     (add-hook 'prog-mode-hook 'linum-mode)
   #+END_SRC

** Mode-line

   [[https://github.com/Bruce-Connor/smart-mode-line][Smart Mode Line]] provides a fairly understandable mode-line format.

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package smart-mode-line
       :init
       (progn
         (if after-init-time (sml/setup)
           (add-hook 'after-init-hook 'sml/setup))

         (setq sml/override-theme nil)

         (add-to-list 'sml/replacer-regexp-list '("^~/Sites/\\([-_A-Za-z0-9.]+\\)/www/" ":\\1:"))
         (add-to-list 'sml/replacer-regexp-list '("^~/Sites/\\([-_A-Za-z0-9.]+\\)/\\([-_A-Za-z0-9]+\\)/" ":\\2.\\1:"))
         (add-to-list 'sml/replacer-regexp-list '("^~/.dots/\\(.*\\)/" ":Config:\\1:"))
         (add-to-list 'sml/replacer-regexp-list '("^~/org/" ":Org:"))

         (add-to-list 'sml/hidden-modes " Projectile")
         (add-to-list 'sml/hidden-modes " EvilOrg")
         (add-to-list 'sml/hidden-modes " Undo-Tree")
         (add-to-list 'sml/hidden-modes " Guide")
         (add-to-list 'sml/hidden-modes " yas")))
   #+END_SRC

** Delimiters

   The parenface package colors parentheses distinctly. The
   rainbow-delimiters package goes a step further and differentiates
   levels of nested parentheses by color. This is mostly useful for
   visually parsing Lisp's parenthesis-heavy syntax.

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package parenface)
     (use-package rainbow-delimiters
       :commands rainbow-delimiters-mode
       :init
       (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))

     (show-paren-mode t)
   #+END_SRC

** Color Names and Codes

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package rainbow-mode
       :commands rainbow-turn-on
       :init
       (add-hook 'prog-mode-hook 'rainbow-turn-on))
   #+END_SRC

* Evil

  Evil mode is a minor mode providing Vim emulation for Emacs. It
  reproduces Vim's modal editing and even certain Ex commands.

  Evil Leader mode provides something like Vim's ~<Leader>~, which is
  set to ~SPC~ below. Here are the conventions used throughout the
  configuration around "namespacing" sets of commands bound to the
  leader key:

  | Key | Description                 |
  |-----+-----------------------------|
  | ~g~   | Git functions (via Magit)   |
  | ~o~   | Option (minor-mode) toggles |
  | ~r~   | Global Org mode functions   |

** Setup

   #+NAME: evil
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package evil
       :pre-load
       (setq evil-want-C-u-scroll t
             evil-want-C-w-in-emacs-state t)
       :config
       (progn
         (require 'evil-leader)
         (require 'evil-numbers)

         (setq evil-default-cursor '("DodgerBlue1" box)
               evil-emacs-state-cursor '("pink" box)
               evil-insert-state-cursor '("white" bar)
               evil-visual-state-cursor '("white" hbar)
               evil-replace-state-cursor '("orange" hbar))

         (evil-mode nil) ; See https://github.com/cofi/evil-leader/issues/10
         (evil-leader/set-leader "<SPC>")
         (global-evil-leader-mode 1)
         (evil-mode 1)
         (evil-set-initial-state 'help-mode 'emacs)
         (evil-set-initial-state 'magit-mode 'emacs)
         (evil-set-initial-state 'package-menu-mode 'normal)))
   #+END_SRC

** TODO Miscellaneous Bindings

   #+NAME: evil
   #+BEGIN_SRC emacs-lisp :tangle no
     (global-set-key (kbd "RET") 'newline-and-indent)

     (evil-leader/set-key
       "e" 'ido-find-file
       "f" 'projectile-find-file
       "d" 'projectile-find-dir
       "p" 'projectile-switch-project
       "D" 'dired
       "T" 'nox/write-timestamped-current-file-copy
       "s" 'ansi-term
       "h" 'dash-at-point
       "P" 'package-list-packages
       ;; Option toggle
       "o n" 'linum-mode
       "o w" 'toggle-truncate-lines)

     (define-key evil-motion-state-map "j" 'evil-next-visual-line)
     (define-key evil-motion-state-map "k" 'evil-previous-visual-line)
     (define-key evil-normal-state-map "Y" (kbd "y$"))

     (define-key evil-normal-state-map "+" 'evil-numbers/inc-at-pt)
     (define-key evil-normal-state-map "_" 'evil-numbers/dec-at-pt)

     (define-key evil-normal-state-map "-" 'dired-jump)
     (evil-define-key 'normal dired-mode-map "-" 'dired-up-directory)

     ;; Escape minibuffer
     (defun nox/minibuffer-keyboard-quit ()
       "Abort recursive edit.

     In Delete Selection mode, if the mark is active, just deactivate it;
     then it takes a second \\[keyboard-quit] to abort the minibuffer."
       (interactive)
       (if (and delete-selection-mode transient-mark-mode mark-active)
           (setq deactivate-mark t)
         (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
         (abort-recursive-edit)))

     (define-key minibuffer-local-map [escape] 'nox/minibuffer-keyboard-quit)
     (define-key minibuffer-local-ns-map [escape] 'nox/minibuffer-keyboard-quit)
     (define-key minibuffer-local-completion-map [escape] 'nox/minibuffer-keyboard-quit)
     (define-key minibuffer-local-must-match-map [escape] 'nox/minibuffer-keyboard-quit)
     (define-key minibuffer-local-isearch-map [escape] 'nox/minibuffer-keyboard-quit)

     (define-key minibuffer-local-map (kbd "C-w") 'backward-kill-word)

     ;; Unimpaired.vim
     (define-key evil-normal-state-map (kbd "[ SPC")
       (lambda () (interactive) (evil-insert-newline-above) (forward-line)))
     (define-key evil-normal-state-map (kbd "] SPC")
       (lambda () (interactive) (evil-insert-newline-below) (forward-line -1)))
     (define-key evil-normal-state-map (kbd "[ e") (kbd "ddkP"))
     (define-key evil-normal-state-map (kbd "] e") (kbd "ddp"))
     (define-key evil-normal-state-map (kbd "[ b") 'previous-buffer)
     (define-key evil-normal-state-map (kbd "] b") 'next-buffer)

     ;; Emacs Lisp
     (evil-leader/set-key-for-mode 'emacs-lisp-mode "C" 'byte-compile-file)
     (evil-leader/set-key-for-mode 'emacs-lisp-mode "E" 'eval-buffer)
     (evil-leader/set-key-for-mode 'emacs-lisp-mode "e" 'eval-defun)
     (evil-leader/set-key-for-mode 'emacs-lisp-mode "x" 'eval-last-sexp)
     (evil-leader/set-key-for-mode 'emacs-lisp-mode "X" 'eval-print-last-sexp)

     ;; Smartparens manipulations
     ;; See all of them here:
     ;; https://github.com/Fuco1/smartparens/wiki/Working-with-expressions
     (evil-define-key 'normal emacs-lisp-mode-map
       (kbd "C-S-k") 'sp-split-sexp
       (kbd "C-S-j") 'sp-join-sexp
       (kbd "C-S-l") 'sp-forward-slurp-sexp
       (kbd "C-S-h") 'sp-backward-slurp-sexp
       (kbd "C-M-l") 'sp-forward-barf-sexp
       (kbd "C-M-h") 'sp-backward-barf-sexp)

     (evil-make-overriding-map package-menu-mode-map 'normal)
     (evil-add-hjkl-bindings package-menu-mode-map 'normal
       "p" 'package-menu-quick-help ; h
       "n" 'evil-search-next)
   #+END_SRC

* Editing

** Text Encodings

   Use UTF-8 encoding wherever possible:

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (set-default-coding-systems 'utf-8-unix)
     (set-terminal-coding-system 'utf-8-unix)
     (set-keyboard-coding-system 'utf-8-unix)
     (prefer-coding-system 'utf-8-unix)
   #+END_SRC

** Utilities

   These packages provide various conveniences for editing.

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package surround
       :commands global-surround-mode
       :idle (global-surround-mode 1))

     (use-package ace-jump-mode
       :commands ace-jump-mode
       :init
       (evil-leader/set-key "SPC" 'ace-jump-mode))

     (use-package smartparens-config
       :commands smartparens-global-mode
       :idle (smartparens-global-mode t)
       :config
       (progn
         ;; Fix handling of {} and [] when hitting RET inside
         (defun nox/sp/pair-on-newline (id action context)
           "Put trailing pair on newline and return to point."
           (save-excursion
             (newline)
             (indent-according-to-mode)))

         (defun nox/sp/pair-on-newline-and-indent (id action context)
           "Open a new brace or bracket expression, with relevant newlines and indent."
           (nox/sp/pair-on-newline id action context)
           (indent-according-to-mode))

         (sp-pair "{" nil :post-handlers
                  '(:add ((lambda (id action context)
                            (nox/sp/pair-on-newline-and-indent id action context)) "RET")))
         (sp-pair "[" nil :post-handlers
                  '(:add ((lambda (id action context)
                            (nox/sp/pair-on-newline-and-indent id action context)) "RET")))))
   #+END_SRC

   When proper source control isn't an option, it's useful to be able
   to create a copy of a file as you are working on it.
   =nox/write-timestamped-current-file-copy= writes the contents of the
   active buffer to a copy with a timestamp appended to the filename.

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (defun nox/write-file-copy (filename)
       (interactive "F")
       (save-restriction (widen)
                         (write-region (point-min) (point-max) filename)))

     (defun nox/write-timestamped-file-copy (filename)
       (interactive "F")
       (let ((timestamp (format-time-string "%Y%m%d-%H%M%S"))
             (filename-head (file-name-sans-extension filename))
             (filename-ext (file-name-extension filename t)))
         (nox/write-file-copy (expand-file-name (concat filename-head "_" timestamp filename-ext)))))

     (defun nox/write-timestamped-current-file-copy ()
       (interactive)
       (nox/write-timestamped-file-copy (buffer-file-name)))
   #+END_SRC

** Scrolling

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq scroll-conservatively 999        ; Never recenter the window on the cursor
           mouse-wheel-scroll-amount '(1))  ; Slower mouse wheel/trackpad scrolling
   #+END_SRC

** Whitespace and Formatting

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq-default indent-tabs-mode nil)

     (setq require-final-newline t) ; auto-insert final newlines in all files

     (use-package whitespace
       :commands (whitespace-cleanup
                  whitespace-mode)
       :init
       (progn
         (evil-leader/set-key "w"   'whitespace-cleanup)
         (evil-leader/set-key "o l" 'whitespace-mode))
       :config
       (progn
         (setq whitespace-line-column 110) ; TODO: only apply to HTML
         (setq whitespace-style '(face
                                  tabs
                                  spaces
                                  trailing
                                  lines-tail
                                  space-before-tab
                                  newline
                                  indentation
                                  empty
                                  space-after-tab
                                  space-mark
                                  tab-mark
                                  newline-mark))))

     (defun nox/indent-buffer ()
             (interactive)
             (save-excursion
                     (indent-region (point-min) (point-max) nil)))

     (evil-leader/set-key "=" 'nox/indent-buffer)

     (defun nox/show-trailing-whitespace ()
             (interactive)
             (setq show-trailing-whitespace t))

     (add-hook 'prog-mode-hook 'nox/show-trailing-whitespace)
   #+END_SRC

** Spelling

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; Use aspell for spell checking: brew install aspell --lang=en
     (setq ispell-program-name "aspell")
     (add-hook 'text-mode-hook 'flyspell-mode)
     (add-hook 'prog-mode-hook 'flyspell-prog-mode)
   #+END_SRC

** Syntax Checking

   Use [[https://github.com/flycheck/flycheck][Flycheck]] to validate syntax on the fly.

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package flycheck
       :commands global-flycheck-mode
       :idle (global-flycheck-mode 1)
       :config (setq-default flycheck-disabled-checkers '(html-tidy emacs-lisp-checkdoc)))
   #+END_SRC

** Version Control and History

   Undo tree provides a Vim-like branching undo history that can be
   visualized and traversed in another window.

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package undo-tree
       :init (evil-leader/set-key "u" 'undo-tree-visualize)
       :config
       (setq undo-tree-visualizer-diff t
             undo-tree-visualizer-timestamps t))
   #+END_SRC

   Magit provides featureful Git integration.

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package magit
       :commands (magit-status magit-diff magit-log magit-blame-mode)
       :init
       (evil-leader/set-key
         "g s" 'magit-status
         "g b" 'magit-blame-mode
         "g l" 'magit-log
         "g d" 'magit-diff)
       :config
       (progn
         (evil-make-overriding-map magit-mode-map 'emacs)
         (define-key magit-mode-map "\C-w" 'evil-window-map)
         (evil-define-key 'emacs magit-mode-map "j" 'magit-goto-next-section)
         (evil-define-key 'emacs magit-mode-map "k" 'magit-goto-previous-section)
         (evil-define-key 'emacs magit-mode-map "K" 'magit-discard-item))) ; k
   #+END_SRC

** Languages
*** Emacs-Lisp

    #+NAME: editing
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package emacs-lisp-mode
        :init
        (use-package eldoc
          :init (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode))
        :mode ("Cask" . emacs-lisp-mode))

      (defun nox/byte-recompile ()
        "`byte-compile' every .el file under `user-emacs-directory' recursively"
        (interactive)
        (byte-recompile-directory user-emacs-directory 0)
        (when (fboundp 'sauron-add-event)
            (sauron-add-event 'editor 2 "Byte compiled Emacs directory")))

      (defun nox/byte-compile-current-buffer ()
        "`byte-compile' current buffer in emacs-lisp-mode if compiled file exists."
        (interactive)
        (when (and (eq major-mode 'emacs-lisp-mode)
                   (file-exists-p (byte-compile-dest-file buffer-file-name)))
          (byte-compile-file buffer-file-name)
          (when (fboundp 'sauron-add-event)
            (sauron-add-event 'editor 2 "Byte compiled buffer"))))

      (add-hook 'after-save-hook 'nox/byte-compile-current-buffer)
    #+END_SRC

*** Ruby

    #+NAME: editing
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package ruby-mode
        :mode (("\\.rake$" . ruby-mode)
               ("\\.gemspec$" . ruby-mode)
               ("\\.ru$" . ruby-mode)
               ("Rakefile$" . ruby-mode)
               ("Gemfile$" . ruby-mode)
               ("Capfile$" . ruby-mode)
               ("Guardfile$" . ruby-mode)))
    #+END_SRC

*** Web

    Web mode provides, among other features, syntax highlighting for
    Javascript and CSS embedded in HTML as well as highlighting for
    various templating languages.

    #+NAME: editing
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package web-mode
        :mode (("\\.html?\\'" . web-mode)
               ("\\.css\\'" . web-mode)
               ("\\.mustache\\'" . web-mode)
               ("\\.erb\\'" . web-mode)))
    #+END_SRC

** Snippets

   Use [[https://github.com/capitaomorte/yasnippet][YASnippet]] for snippets:

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package yasnippet
       :commands yas-global-mode
       :idle (yas-global-mode t)
       :init
       (progn
         ;; Suppress excessive log messages
         (setq yas-verbosity 1)))
   #+END_SRC

** Expansion

   Use [[http://www.gnu.org/software/emacs/manual/html_node/autotype/Hippie-Expand.html][hippie-expand]] for inline expansion in all modes:

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (global-set-key (kbd "M-/") 'hippie-expand)
   #+END_SRC

* Navigation and Completion

** Ido

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package ido
       :init
       (progn
         (ido-mode t)
         (ido-everywhere t)
         (ido-ubiquitous-mode t))

       :config
       (progn
         (setq ido-enable-flex-matching t)
         (add-to-list 'ido-ignore-files "\\.DS_Store")

         (add-hook 'ido-setup-hook 'nox/ido-setup)

         (defun nox/ido-setup ()
           "Add Evil-mode-like key bindings for ido."
           (define-key ido-completion-map (kbd "C-j") 'ido-next-match)
           (define-key ido-completion-map (kbd "C-k") 'ido-prev-match))

         (use-package ido-vertical-mode
           :init
           (ido-vertical-mode))))
   #+END_SRC

** Smex

   Smex provides Ido completion for ~M-x~.

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package smex
       :bind (("M-x" . smex)
              ("M-X" . smex-major-mode-commands))
       :init
       (progn
         (setq smex-save-file (expand-file-name "smex-items" nox/ephemeral-directory))
         (setq smex-history-length 10)
         (setq smex-flex-matching t)
         (smex-initialize)))
   #+END_SRC

** Buffers

   For more intensive buffer switching and buffer management, we use
   ibuffer, which displays a listing in its own
   buffer. =ibuffer-saved-filter-groups= defines rules for grouping
   buffers under categories ("filter groups").

   The [[https://github.com/purcell/ibuffer-vc][ibuffer-vc]] package generates filter groups for consumption by
   ibuffer that categorize buffers by version control repository root.

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package ibuffer
       :commands ibuffer
       :init
       (progn
         (setq ibuffer-saved-filter-groups
               '(("Config" (or
                            (filename . ".dots/")
                            (filename . ".emacs.d/")))
                 ("Shell"  (or
                            (mode . eshell-mode)
                            (mode . shell-mode)))
                 ("Dired"  (mode . dired-mode))
                 ("Prose"  (or
                            (mode . tex-mode)
                            (mode . plain-tex-mode)
                            (mode . latex-mode)
                            (mode . rst-mode)
                            (mode . markdown-mode)))
                 ("Org"    (mode . org-mode))
                 ("Gnus"   (or
                            (mode . message-mode)
                            (mode . gnus-group-mode)
                            (mode . gnus-summary-mode)
                            (mode . gnus-article-mode)))
                 ("Emacs"  (name . "^\\*.*\\*$")))
               ibuffer-show-empty-filter-groups nil
               ibuffer-expert t)

         (use-package ibuffer-vc
           :commands ibuffer-vc-generate-filter-groups-by-vc-root
           :init
           (progn
             (defun nox/ibuffer-apply-filter-groups ()
               "Combine my saved ibuffer filter groups with those generated
          by `ibuffer-vc-generate-filter-groups-by-vc-root'"
               (interactive)
               (setq ibuffer-filter-groups
                     (append (ibuffer-vc-generate-filter-groups-by-vc-root)
                             ibuffer-saved-filter-groups))
               (message "ibuffer-vc: groups set")
               (let ((ibuf (get-buffer "*Ibuffer*")))
                 (when ibuf
                   (with-current-buffer ibuf
                     (pop-to-buffer ibuf)
                     (ibuffer-update nil t)))))

             (add-hook 'ibuffer-hook 'nox/ibuffer-apply-filter-groups)))))
   #+END_SRC

   Set up convenient un-chorded maps:

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (evil-leader/set-key
       "b" 'ido-switch-buffer
       "B" 'ibuffer)
   #+END_SRC

   Clean up buffers periodically:

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package midnight)
   #+END_SRC

** Helm

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package helm-config)
   #+END_SRC

** Find in Project

   [[https://github.com/bbatsov/projectile][Projectile]] allows easy switching between projects as well as
   finding files and buffers related to the current project, however
   it does not implement its own interface, instead leveraging Ido,
   Helm, or Grizzl.

   Projectile's bindings start with ~C-c p~.

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package projectile
       :init
       (progn
         (setq projectile-show-paths-function 'projectile-hashify-with-relative-paths)
         (projectile-global-mode))
       :config
       (progn
         ;; TODO: This can probably be done more elegantly with :bind
         (define-key projectile-mode-map [?\s-f] 'projectile-find-file)
         (define-key projectile-mode-map [?\s-b] 'projectile-switch-to-buffer)
         (define-key projectile-mode-map [?\s-k] 'projectile-kill-buffers)
         (define-key projectile-mode-map [?\s-d] 'projectile-find-dir)
         (define-key projectile-mode-map [?\s-D] 'projectile-dired)
         (define-key projectile-mode-map [?\s-g] 'projectile-grep)
         (define-key projectile-mode-map [?\s-p] 'projectile-switch-project)))
   #+END_SRC

** Auto-completion

   Use [[http://cx4a.org/software/auto-complete/index.html][Auto Complete Mode]] for inline completion in certain major modes:

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package auto-complete-config
       :init
       (progn
         (use-package pos-tip)

         (add-to-list 'ac-dictionary-directories (expand-file-name "ac-dict" user-emacs-directory))
         ;; User-defined dictionary goes in "~/.dict" by default.

         ;; The default value of ac-sources is
         ;; '(ac-source-abbrev ac-source-dictionary ac-source-words-in-same-mode-buffers)
         ;; and then this is overridden for a handful of major modes.
         ;;
         ;; Add a couple of non-default sources to ac-sources for all buffers
         ;; by redefining this function called from (ac-config-default):
         (defun ac-common-setup ()
           (setq ac-sources (append ac-sources '(ac-source-yasnippet
                                                 ac-source-filename))))

         (setq ac-comphist-file (expand-file-name "ac-comphist.dat" nox/ephemeral-directory))
         (setq ac-auto-start 1) ; Number of characters typed before completion starts

         (ac-config-default)
         (ac-flyspell-workaround)
         (ac-linum-workaround)))
   #+END_SRC

** Key Bindings

   Completion of sorts for key sequences is provided by [[https://github.com/kbkbkbkb1/guide-key][guide-key]]:

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package guide-key
       :init
       (progn
         (guide-key-mode 1))
       :config
       (progn
         (setq guide-key/recursive-key-sequence-flag t
               guide-key/align-command-by-space-flag t
               guide-key/popup-window-position 'bottom)

         ;; Sequences of interest globally
         (setq guide-key/guide-key-sequence '("C-x r"
                                              "C-x 4"   ; Other window commands
                                              "C-x 5"   ; Other frame commands
                                              "C-x c"   ; Helm prefix
                                              "C-c p"   ; Projectile prefix
                                              "C-c P")) ; Project-persist prefix

         ;; Sequences of interest for specific modes
         (defun guide-key/my-hook-function-for-org-mode ()
           (guide-key/add-local-guide-key-sequence "C-c")
           (guide-key/add-local-guide-key-sequence "C-c C-x")
           (guide-key/add-local-highlight-command-regexp "org-"))
         (add-hook 'org-mode-hook 'guide-key/my-hook-function-for-org-mode)))
   #+END_SRC

* Org

** Basic Settings

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'org)
     (use-package evil-org)

     ;; http://orgmode.org/worg/org-contrib/org-mac-message.html
     (add-to-list 'org-modules 'org-mac-message)

     ;; Track habits
     (add-to-list 'org-modules 'org-habit)
     (use-package org-habit
       :config
       (setq org-habit-show-habits-only-for-today nil))

     (setq org-directory "~/org"
           org-default-notes-file (expand-file-name "agenda.org" org-directory))

     ;; http://lists.gnu.org/archive/html/emacs-orgmode/2013-02/msg00644.html
     (org-agenda-to-appt)             ;; generate the appt list from org agenda files on emacs launch
     (run-at-time "24:01" 3600 'org-agenda-to-appt)           ;; update appt list hourly
     (add-hook 'org-finalize-agenda-hook 'org-agenda-to-appt) ;; update appt list on agenda view

     (setq org-capture-templates
           '(("t" "To-do" entry
              (file+headline "" "Inbox")
              "* TODO %u %^{Task}"
              :clock-keep t :kill-buffer t)
             ("d" "To-do (done)" entry
              (file+headline "" "Inbox")
              "* DONE %u %^{Task}"
              :clock-keep t :kill-buffer t)
             ("q" "Quick to-do" entry
              (file+headline "" "Inbox")
              "* TODO %^{Task}\n  SCHEDULED: %t"
              :clock-keep t :kill-buffer t :immediate-finish t)))

     (setq org-goto-interface 'outline-path-completion
           org-log-done 'time
           org-log-into-drawer t
           org-refile-allow-creating-parent-nodes 'confirm
           org-refile-use-outline-path t
           org-return-follows-link t
           org-catch-invisible-edits 'show-and-error)

     (setq org-todo-keywords '((sequence
                                "TODO(t)"
                                "STARTED(s!)"
                                "WAITING(w@/!)"
                                "|"
                                "CANCELED(c@)"
                                "DONE(d!)"
                                )))

     (setq org-hide-leading-stars t)

     ;; Code blocks
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (sh . t)))
     (setq org-src-fontify-natively t
           org-src-tab-acts-natively t)
   #+END_SRC

** Templates

   Org mode provides a mechanism for inserting [[http://orgmode.org/manual/Easy-Templates.html][templates]] into Org
   documents. To insert a structural element, type a ~<~, followed by a
   template selector and ~<TAB>~.

** Tags

   Org headlines can be tagged such that they are easier to find and
   filter. Here we set up reusable tags with mnemonic shortcuts.

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq org-tag-alist '(("@work" . ?W)     ; Contexts
                           ("@home" . ?H)
                           ("@school" . ?S)
                           ("@errand" . ?E)
                           ("build" . ?b)     ; Task types
                           ("earn" . ?e)
                           ("learn" . ?l)
                           ("focus" . ?f)     ; Task statuses
                           ("someday" . ?s)
                           ("delegate" . ?d)))
   #+END_SRC

** Exporting

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq org-hide-emphasis-markers t
           org-export-with-section-numbers nil
           org-export-html-preamble nil
           org-export-html-postamble nil
           org-export-html-style-include-default nil
           org-export-html-style-include-scripts nil
           org-export-html-style "<link rel=\"stylesheet\" type=\"text/css\" href=\"org.css\" />\n"
           org-export-html-style-extra "<meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1\" />")
   #+END_SRC

** Key Bindings

#+INCLUDE: "org_key_bindings.org"

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; Org mode - http://orgmode.org/guide/Activation.html#Activation
     (evil-leader/set-key
       "r a" 'org-agenda
       "r b" 'org-iswitchb
       "r c" 'org-capture
       "r l" 'org-store-link)

     (eval-after-load 'org-agenda
       '(progn
          ;; Use the standard Org agenda bindings as a base
          (evil-make-overriding-map org-agenda-mode-map 'emacs t)
          (evil-define-key 'emacs org-agenda-mode-map "j" 'org-agenda-next-line)
          (evil-define-key 'emacs org-agenda-mode-map "k" 'org-agenda-previous-line)
          (evil-define-key 'emacs org-agenda-mode-map (kbd "C-j") 'org-agenda-goto-date) ; "j"
          (evil-define-key 'emacs org-agenda-mode-map "n" 'org-agenda-capture)))         ; "k"
   #+END_SRC

** Clocking Time

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package org-clock
       :init
       (progn
         (setq org-clock-persist-file (expand-file-name ".org-clock-save.el" org-directory)
               org-clock-persist t
               ;; Do not prompt to resume an active clock
               ;org-clock-persist-query-resume nil
               ;; Resume clocking task on clock-in if the clock line is open
               org-clock-in-resume t
               org-clock-in-switch-to-state "STARTED"
               org-clock-out-remove-zero-time-clocks t
               org-clock-out-when-done t
               org-clock-idle-time 20
               ;; Include current clocking task in clock reports
               org-clock-report-include-clocking-task t)

         ;; Resume clocking tasks when emacs is restarted
         (org-clock-persistence-insinuate)))
   #+END_SRC

** Agenda

*** Basic Configuration

    #+NAME: org
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package org-agenda)

      (setq org-agenda-files '("~/org")
            org-agenda-skip-unavailable-files t
            org-agenda-skip-deadline-if-done nil
            org-agenda-skip-scheduled-if-done nil
            org-agenda-restore-windows-after-quit t
            org-agenda-window-setup 'other-window
            org-agenda-show-all-dates t
            org-agenda-show-log t
            org-agenda-diary-file (expand-file-name "diary.org" org-directory)
            org-agenda-include-diary t)
    #+END_SRC

*** Custom Agenda Commands

    Below are our custom agenda commands:

    | Key | Description                                   |
    |-----+-----------------------------------------------|
    | ~d~   | Timeline for today, including a clock summary |
    | ~w~   | Items with status WAITING                     |
    | ~U~   | Important tasks that I might tend to avoid    |
    | ~P~   | Items by priority                             |

    #+NAME: org
    #+BEGIN_SRC emacs-lisp :tangle no
      (setq org-agenda-custom-commands
            `(("d" "Timeline for today" ((agenda "" ))
               ((org-agenda-ndays 1)
                (org-agenda-show-log t)
                (org-agenda-log-mode-items '(clock closed))
                (org-agenda-clockreport-mode t)
                (org-agenda-entry-types '())))
              ("w" "Waiting for" todo "WAITING"
               ((org-agenda-sorting-strategy '(priority-down))))
              ("U" "Important stuff I don't want to do"
               ((tags-todo "focus")))
              ("P" "By priority"
               ((tags-todo "+PRIORITY=\"A\"")
                (tags-todo "+PRIORITY=\"B\"")
                (tags-todo "+PRIORITY=\"\"")
                (tags-todo "+PRIORITY=\"C\""))
               ((org-agenda-prefix-format "%-10c %-10T %e ")
                (org-agenda-sorting-strategy '(priority-down tag-up category-keep effort-down))))))
    #+END_SRC

*** Automatically Show Agenda

    I tend not to consult the agenda often enough, so let's show it
    after Emacs is idle for a while.

    #+NAME: org
    #+BEGIN_SRC emacs-lisp :tangle no
      (defun nox/jump-to-org-agenda ()
        (interactive)
        (let ((buf (get-buffer "*Org Agenda*"))
              wind)
          (if buf
              (if (setq wind (get-buffer-window buf))
                  (select-window wind)
                (if (called-interactively-p)
                    (progn
                      (select-window (display-buffer buf t t))
                      (org-fit-window-to-buffer))
                  (with-selected-window (display-buffer buf)
                    (org-fit-window-to-buffer))))
            (call-interactively 'org-agenda-list))))

      (run-with-idle-timer 2400 t 'nox/jump-to-org-agenda)
    #+END_SRC

** Appointments

   Use the ~appt~ package for displaying appointment alerts. The
   following was derived from [[http://lists.gnu.org/archive/html/emacs-orgmode/2013-02/msg00644.html][this message]] on the Org mode mailing
   list.

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package appt
       :init
       (progn
         (setq appt-message-warning-time '30) ;; Send first warning 30 minutes before appointment
         (setq appt-display-interval '15)     ;; Warn every 15 minutes from appt-message-warning-time
         (appt-activate 1)))                  ;; Activate appointment notification
   #+END_SRC

** Mobile

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package org-mobile
       :init
       (progn
         ;; Set to the name of the file where new notes will be stored
         (setq org-mobile-inbox-for-pull (expand-file-name "mobile-flagged.org" org-directory)
               org-mobile-directory "~/Dropbox/Apps/MobileOrg"
               org-mobile-agendas '("a")
               org-mobile-force-id-on-agenda-items nil
               ;; org-mobile-encryption-password is set in private.el
               org-mobile-use-encryption t)

         (defvar nox/org-mobile-sync-timer nil)
         (defvar nox/org-mobile-sync-secs (* 60 20))

         (defun nox/org-mobile-sync-pull-and-push ()
           (org-mobile-pull)
           (org-mobile-push)
           (when (fboundp 'sauron-add-event)
             (sauron-add-event 'org-mobile 3 "Finished MobileOrg sync")))

         (defun nox/org-mobile-sync-start ()
           "Start automated `org-mobile-push'"
           (interactive)
           (setq nox/org-mobile-sync-timer
                 (run-with-idle-timer nox/org-mobile-sync-secs t
                                      'nox/org-mobile-sync-pull-and-push)))

         (defun nox/org-mobile-sync-stop ()
           "Stop automated `org-mobile-push'"
           (interactive)
           (cancel-timer nox/org-mobile-sync-timer))

         (add-hook 'after-init-hook 'nox/org-mobile-sync-start)
         (add-hook 'kill-emacs-hook 'org-mobile-push)))
   #+END_SRC

** TeamworkPM Integration

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar twpm-executable-path "~/bin/twpm")

     (defun nox/twpm-timelog (task-id date time hours minutes)
       "Call twpm script with parameters, allowing you to submit time-tracking info
     to the TeamworkPM API."
       (shell-command (format "%s --task-id=%s --date=%s --time=%s --hours=%s --minutes=%s"
                      twpm-executable-path
                      task-id
                      date
                      time
                      hours
                      minutes))
       (message (format "Task %s: submitted %s:%s for %s"
                        task-id
                        hours
                        minutes
                        date)))

     (defun nox/twpm-timelog-get-clock-table-date ()
       (save-excursion
         (re-search-backward "^Daily report: \\[\\([0-9-]+\\) ")
         (match-string 1)))

     (defun nox/twpm-timelog-get-clock-table-row-id ()
       (save-excursion
         (beginning-of-line)
         (re-search-forward "^| +| +\\([0-9]+\\) +|")
         (match-string 1)))

     (defun nox/twpm-timelog-get-clock-table-row-hours ()
       (save-excursion
         (beginning-of-line)
         (re-search-forward "| +\\([0-9]+\\):[0-9]+ |$")
         (match-string 1)))

     (defun nox/twpm-timelog-get-clock-table-row-minutes ()
       (save-excursion
         (beginning-of-line)
         (re-search-forward "| +[0-9]+:\\([0-9]+\\) |$")
         (match-string 1)))

     (defun nox/twpm-timelog-from-clock-table ()
       "With the point placed on an org-mode clock table row, submit the time to the
     TeamworkPM API. Note that this only works on clock tables with step: day."
       (interactive)
       (let ((task-id (nox/twpm-timelog-get-clock-table-row-id))
             (date (nox/twpm-timelog-get-clock-table-date))
             (time "00:00")
             (hours (nox/twpm-timelog-get-clock-table-row-hours))
             (minutes (nox/twpm-timelog-get-clock-table-row-minutes)))
         (nox/twpm-timelog task-id date time hours minutes)))
   #+END_SRC

** Invoicing

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar invoice-dir "~/Documents/Invoices/")
     (defvar invoice-template-path (expand-file-name "_template.org" invoice-dir))

     (defun nox/invoice-next-number ()
       "Get next sequential invoice number. Invoice numbers are in the format YYYYXXX,
     where YYYY is the current year and XXX is a zero-padded sequential counter
     modulo 1000. Ex.: 2016001."
       (concat (format-time-string "%Y" (current-time))
               (format "%03d" (% (1+ (string-to-number
                                   (substring (car (last (directory-files
                                           invoice-dir
                                           nil
                                           "^[0-9]+\.org$"))) 4 7))) 1000))))

     (defun nox/invoice-get-path (number)
       "Derive invoice file path from invoice NUMBER."
       (format "%s/%s.org" invoice-dir number))

     (defun nox/invoice-create (scope-file)
       "Make a new invoice from given file and date range."
       (interactive "forg file: ")
       (let ((invoice-number (nox/invoice-next-number))
             (invoice-date (format-time-string "%m/%d/%Y" (current-time)))
             (invoice-start (org-read-date nil t nil "Choose invoice start" nil "-2Mon"))
             (invoice-end (org-read-date nil nil nil "Choose invoice end" nil "-Sun")))
         (find-file (nox/invoice-get-path invoice-number))
         (insert-file-contents invoice-template-path)
         (goto-char (point-min))
         (while (search-forward "@INVOICE_NUMBER@" nil t)
           (replace-match invoice-number))
         (goto-char (point-min))
         (while (search-forward "@SCOPE_FILE@" nil t)
           (replace-match scope-file))
         (org-update-all-dblocks)))

     (defun nox/invoice-create-from-current-buffer-file ()
       "Make a new invoice from current buffer's file and given date range."
       (interactive)
       (nox/invoice-create (buffer-file-name)))
   #+END_SRC

* Notifications and ERC

** ERC

   ERC is an extensible IRC client for Emacs. We keep our
   configuration in a separate =erc-config.el= file that gets autoloaded
   upon invoking ~nox/erc~.

   #+NAME: notifications
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package erc-config
       :commands (nox/erc erc))
   #+END_SRC

** Terminal Notifier

   #+NAME: notifications
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar nox/notifier-program-name
       "terminal-notifier")

     (defun nox/send-notification (title msg &optional group)
       (let ((group (if group (format " -group %s" group)))
             (msg (format " -message '%s'" msg))
             (title (format " -title '%s'" title))
             (sender " -sender org.gnu.Emacs"))
         (shell-command (concat nox/notifier-program-name
                                msg
                                title
                                sender
                                group))))
   #+END_SRC

** Alert

   #+NAME: notifications
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package alert
       :config
       (progn
         (setq alert-default-style 'terminal-notifier)

         (alert-define-style 'terminal-notifier :title "Terminal Notifier"
                             :notifier
                             (lambda (info)
                               (nox/send-notification
                                (plist-get info :title)
                                (plist-get info :message)
                                (plist-get info :category))))))
   #+END_SRC

** Sauron

   #+NAME: notifications
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package sauron
       :config
       (progn
         ;; Pass notifications through to alert.el
         (add-hook 'sauron-event-added-functions 'sauron-alert-el-adapter)

         ;; Show in a split rather than a separate frame
         (setq sauron-separate-frame nil
               sauron-hide-mode-line t)

         (global-set-key (kbd "C-c s") 'sauron-toggle-hide-show)
         (global-set-key (kbd "C-c t") 'sauron-clear)))
   #+END_SRC

* Configuration Layout

  Here we define the ~emacs.el~ file that gets generated by the source
  blocks in our Org document. This is the file that actually gets
  loaded on startup.

  #+BEGIN_SRC emacs-lisp :tangle yes :noweb no-export :exports code
    ;;; emacs.el --- Emacs configuration generated via Org Babel

    ;;; Commentary:

    ;; Do not modify this file by hand.  It was automatically generated
    ;; from `emacs.org` in the same directory.  See that file for more
    ;; information.

    ;;; Code:

    ;; Configuration group: init-before
    <<init-before>>

    ;; Configuration group: appearance
    <<appearance>>

    ;; Configuration group: evil
    <<evil>>

    ;; Configuration group: editing
    <<editing>>

    ;; Configuration group: navigation-completion
    <<navigation-completion>>

    ;; Configuration group: org
    <<org>>

    ;; Configuration group: notifications
    <<notifications>>

    ;; Configuration group: init-after
    <<init-after>>

    ;; emacs.el ends here
  #+END_SRC

* Wish List

  Functionality I want or things that need to be fixed:

  - Feature: remap ~C-j~ / ~C-k~ in Helm buffer.
  - Use Emacs for RSS. =newsticker.el= seemed promising, but it
    caused Emacs to hang on startup while it fetched feeds and it
    couldn't handle half the feeds for some reason. =elfeed.el= was
    overly complicated and also couldn't handle some feeds. Gnus is
    ridiculous.
